#!/usr/bin/env python3
import subprocess
import sys
import re
import shutil
import requests
from datetime import datetime
import os

# Debug mode - set to True to see detailed information
DEBUG = True

def debug_print(message):
    if DEBUG:
        print(f"[DEBUG] {message}")

# Add your Vulners API key here
VULNERS_API_KEY = "EUOBLZ5P3VY5KZYUBL2EKHZUTI2REOY2CH6YQL90A52D2V0B6DOHX7MFUF17F4SM"  # <-- insert your actual API key

SERVICES = {
    21: ("FTP", ["Anonymous access", "Backdoor RCE"], ["nmap", "searchsploit", "metasploit"]),
    22: ("SSH", ["Weak passwords", "Outdated SSHd"], ["nmap", "hydra", "searchsploit"]),
    25: ("SMTP", ["Open relay", "Command injection"], ["nmap", "swaks", "metasploit"]),
    80: ("HTTP", ["XSS, SQLi, RCE", "Outdated Apache/nginx"], ["nmap", "nikto", "burpsuite"]),
    443: ("HTTPS", ["Weak TLS/SSL", "App vulns"], ["sslscan", "owasp zap", "burpsuite"]),
    139: ("NetBIOS", ["Enumerate shares", "SMBv1 enabled"], ["nmap", "smbclient"]),
    445: ("SMB", ["EternalBlue", "Unsecured shares"], ["smbmap", "nmap", "metasploit"]),
    3306: ("MySQL", ["Default creds", "SQLi"], ["sqlmap", "metasploit"]),
    3389: ("RDP", ["BlueKeep", "Weak credentials"], ["nmap", "hydra", "rdesktop"]),
    5432: ("PostgreSQL", ["Default creds", "SQLi"], ["sqlmap", "nmap"]),
    5900: ("VNC", ["No auth", "Weak password"], ["vncviewer", "hydra"]),
    8080: ("HTTP Proxy", ["RCE, SSRF", "Misconfig"], ["nikto", "burpsuite"]),
    10000: ("Webmin", ["RCE", "Default credentials"], ["nmap", "metasploit"])
}

SUSPECT_KEYWORDS = ["share", "myshare", "tmp", "usr", "var", "media", "bin", "secure", "secu", "private", "public"]
SUSPECT_EXTS = [".bak", ".zip", ".rar", ".7z", ".gz", ".secret", ".key", ".pem", ".txt", "password", "passwd", ".conf", ".cnf", ".ini"]

def is_tool_installed(tool):
    return shutil.which(tool) is not None

def run_nmap(ip):
    print(f"[+] Scanning {ip} for top 100 ports...")
    cmd = ["nmap", "-sV", "--top-ports", "100", "-Pn", "-oN", "nmap_output.txt", ip]
    subprocess.run(cmd)

def parse_nmap_results():
    results = []
    try:
        with open("nmap_output.txt", "r") as f:
            for line in f:
                match = re.match(r"^(\d+)/tcp\s+open\s+([\w\-]+)\s+(.*)", line)
                if match:
                    port = int(match.group(1))
                    service = match.group(2)
                    version = match.group(3).strip()
                    results.append((port, service, version))
    except Exception as e:
        print(f"[!] Error parsing nmap results: {e}")
    return results

def search_cves(service, version):
    query = f"{service} {version}"
    url = "https://vulners.com/api/v3/search/lucene/"
    headers = {"User-Agent": "quickpentest"}
    params = {
        "query": query,
        "apiKey": VULNERS_API_KEY,
        "sort": "cvss.score",
        "size": 3
    }
    try:
        r = requests.get(url, headers=headers, params=params, timeout=10)
        if r.status_code == 200:
            data = r.json()
            results = data.get("data", {}).get("search", [])
            if not results:
                return "  ➤ Aucun CVE trouvé pour cette version. Continuation du scan..."
            output = []
            for item in results:
                cve_id = item.get("id")
                score = item.get("cvss", {}).get("score", "N/A")
                title = item.get("title", "")
                output.append(f"    - {cve_id} (CVSS: {score}) – {title}")
            return "\n".join(output)
        else:
            return "  ➤ Erreur API Vulners. Scan continue..."
    except Exception as e:
        return f"  ➤ Recherche CVE échouée: {str(e)}"

def scan_smb_shares(ip, report_file):
    """Simplified SMB share scanner that lists and downloads suspect files."""
    smb_results = []
    smb_results.append(f"\nPHASE: ANALYSE DES PARTAGES SMB\n----------------------------------------\n")

    try:
        debug_print(f"Scanning SMB shares on {ip}")
        cmd = ["smbclient", "-L", f"//{ip}/", "-N"]
        debug_print(f"Running command: {' '.join(cmd)}")
        smb_list = subprocess.check_output(cmd, stderr=subprocess.STDOUT, timeout=30).decode()
        debug_print(f"Raw SMB list output:\n{smb_list[:300]}...")

        shares = re.findall(r"\n\s*(\S+)\s+Disk\s+", smb_list)
        shares = [s for s in shares if s not in ["print$", "IPC$"]]
        shares = list(set(shares))  # Remove duplicates
        debug_print(f"Detected shares: {shares}")

        if not shares:
            smb_results.append("  [!] Aucun partage SMB détecté ou accès refusé.\n")
            with open(report_file, "a") as out:
                for line in smb_results:
                    out.write(line)
            return

        smb_results.append(f"  [+] Partages trouvés : {', '.join(shares)}\n")

        for share in shares:
            smb_results.append(f"\n  📁 Partage : {share}\n")
            debug_print(f"Analyzing share: {share}")
            try:
                # List files recursively
                list_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "prompt OFF; recurse ON; ls"]
                debug_print(f"Running command: {' '.join(list_cmd)}")
                result = subprocess.check_output(list_cmd, stderr=subprocess.DEVNULL, timeout=30).decode()
                debug_print(f"Share listing result preview:\n{result[:300]}...")

                file_count = 0
                suspect_files = []
                current_path = ""  # Track the current directory path during recursion

                for line in result.splitlines():
                    line = line.strip()
                    if not line or 'blocks of size' in line:
                        continue

                    # Handle directory changes (smbclient outputs dir paths when recursing)
                    if line.startswith("dir:"):
                        current_path = line.split("dir:", 1)[1].strip()
                        if current_path == ".":
                            current_path = ""
                        continue

                    # Skip directory entries (lines with "D" or ending with "/")
                    tokens = line.split()
                    if not tokens or len(tokens) < 2 or "D" in tokens or line.endswith("/"):
                        continue

                    # Extract filename (first non-metadata token)
                    filename = next((tok for tok in tokens if not tok.isdigit() and not re.match(r'^\d{2}:\d{2}:\d{2}', tok)), tokens[0])
                    file_count += 1

                    # Construct full path for the file
                    full_path = filename if not current_path else f"{current_path}/{filename}"

                    # Detect suspect files
                    if any(ext in filename.lower() for ext in SUSPECT_EXTS):
                        suspect_files.append(full_path)
                        debug_print(f"Suspect file found: {full_path}")

                        # Download the suspect file
                        try:
                            get_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", f'get "{full_path}"']
                            debug_print(f"Downloading suspect file: {' '.join(get_cmd)}")
                            subprocess.run(get_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=30)
                            local_filename = os.path.basename(full_path)
                            if os.path.exists(local_filename):
                                debug_print(f"Successfully downloaded {full_path} as {local_filename}")
                                smb_results.append(f"    - Downloaded suspect file: {local_filename}\n")
                            else:
                                debug_print(f"Failed to download {full_path}")
                                smb_results.append(f"    - Failed to download suspect file: {full_path}\n")
                        except Exception as e:
                            debug_print(f"Error downloading {full_path}: {str(e)}")
                            smb_results.append(f"    - Error downloading suspect file {full_path}: {str(e)}\n")

                smb_results.append(f"    - Fichiers trouvés : {file_count}\n")
                if suspect_files:
                    smb_results.append(f"    - 🧪 Fichiers suspects :\n")
                    for f in suspect_files:
                        smb_results.append(f"      • {f}\n")
                else:
                    smb_results.append("    - Aucun fichier suspect détecté.\n")

            except subprocess.TimeoutExpired:
                smb_results.append(f"    [!] Timeout while listing share {share}\n")
            except subprocess.CalledProcessError as e:
                smb_results.append(f"    [!] Accès refusé ou erreur lors du listing pour {share}: {e.output.decode()}\n")
                debug_print(f"Error accessing share {share}: {e}")

    except subprocess.TimeoutExpired:
        smb_results.append(f"  [!] Timeout during SMB share enumeration\n")
    except subprocess.CalledProcessError as e:
        smb_results.append(f"  [!] SMB enumeration error: {e.output.decode()}\n")
    except Exception as e:
        smb_results.append(f"  [!] Erreur SMB globale : {str(e)}\n")
        debug_print(f"Global SMB scan error: {e}")

    with open(report_file, "a") as out:
        for line in smb_results:
            out.write(line)

def generate_report(ip, results):
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open("report.txt", "w") as f:
        f.write(f"Rapport de Pentest – Généré automatiquement\n")
        f.write(f"IP Cible: {ip}\nDate: {now}\nDurée estimée: Automatisée\nMéthode: Boîte noire\n\n")
        f.write("PHASE: SCAN + ENUMÉRATION\n--------------------------\n\n")
        for port, service, version in results:
            f.write(f" - Port {port} ({service}) → Version: {version}\n")

        f.write("\nPHASE: VULNÉRABILITÉS POSSIBLES\n--------------------------------\n")
        for port, service, version in results:
            if port in SERVICES:
                name, vulns, tools = SERVICES[port]
                f.write(f"Port {port} ({name})\n")
                f.write(f"  ➤ Version détectée: {version}\n")
                f.write("  ➤ Vulnérabilités possibles:\n")
                for vuln in vulns:
                    f.write(f"    - {vuln}\n")
                f.write("  ➤ Outils recommandés:\n")
                for tool in tools:
                    status = "✔ installé" if is_tool_installed(tool) else "✘ non trouvé"
                    f.write(f"    - {tool} ({status})\n")
                cve_results = search_cves(service, version)
                f.write("  ➤ Résultats CVE :\n")
                f.write(f"{cve_results}\n\n")
        
        if any(port in [139, 445] for port, _, _ in results):
            scan_smb_shares(ip, "report.txt")
        
        f.write("\nPHASE: POST-SCAN (si outils disponibles)\n----------------------------------------\n")
        if is_tool_installed("nikto") and any(port == 80 for port, _, _ in results):
            f.write("[+] Lancement rapide de Nikto sur port 80...\n")
            subprocess.run(["nikto", "-host", f"http://{ip}", "-p", "80"])
        else:
            f.write("✘ nikto non installé ou port 80 fermé. Étape ignorée.\n")

        if is_tool_installed("dirsearch") and any(port == 80 for port, _, _ in results):
            f.write("[+] Exécution rapide de dirsearch...\n")
            subprocess.run(["dirsearch", "-u", f"http://{ip}:80", "-e", "php,txt,html", "--simple-report=dirsearch_report.txt"])
        else:
            f.write("✘ dirsearch non installé ou port 80 fermé. Étape ignorée.\n")

        if is_tool_installed("gobuster") and any(port == 80 for port, _, _ in results):
            f.write("[+] Gobuster dir...\n")
            subprocess.run(["gobuster", "dir", "-u", f"http://{ip}", "-w", "/usr/share/wordlists/dirb/common.txt", "-q", "-o", "gobuster_output.txt"])
        else:
            f.write("✘ gobuster non installé ou port 80 fermé. Étape ignorée.\n")

        f.write("\nFIN DU RAPPORT – Vérifiez les téléchargements et exploitez manuellement si nécessaire.\n")

    print("[+] Rapport terminé dans report.txt")

def test_smb_connection(ip):
    """Test SMB connection and list shares"""
    print(f"[TEST] Testing SMB connection to {ip}")
    try:
        cmd = ["smbclient", "-L", f"//{ip}/", "-N"]
        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode()
        print(f"[TEST] Output:\n{output}")
        
        shares1 = re.findall(r"\n\s*(\S+)\s+Disk\s+", output)
        shares2 = re.findall(r"(\S+)\s+Disk\s+.*", output)
        
        print(f"[TEST] Detected shares (pattern 1): {shares1}")
        print(f"[TEST] Detected shares (pattern 2): {shares2}")
        
        all_shares = list(set(shares1 + shares2))
        print(f"[TEST] All detected shares: {all_shares}")
        
        for share in all_shares:
            if share in ['print$', 'IPC$'] or share.startswith('-'):
                print(f"[TEST] Skipping standard share: {share}")
                continue
                
            print(f"[TEST] Testing access to share: {share}")
            list_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "ls"]
            try:
                share_output = subprocess.check_output(list_cmd, stderr=subprocess.STDOUT).decode()
                print(f"[TEST] Share content preview:\n{share_output[:200]}...")
                
                recur_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "prompt OFF; recurse ON; ls"]
                recur_output = subprocess.check_output(recur_cmd, stderr=subprocess.STDOUT).decode()
                print(f"[TEST] Recursive listing preview:\n{recur_output[:200]}...")
                
                suspect_files = []
                for line in recur_output.splitlines():
                    if any(ext in line.lower() for ext in [".txt", ".bak", ".conf"]):
                        print(f"[TEST] Suspect file line: {line}")
                        parts = line.split()
                        for part in parts:
                            if "." in part and len(part) > 3:
                                suspect_files.append(part)
                
                print(f"[TEST] Potential suspect files: {suspect_files}")
                
                if suspect_files:
                    sample = suspect_files[0]
                    print(f"[TEST] Attempting to download: {sample}")
                    get_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", f'get "{sample}"']
                    dl_output = subprocess.run(get_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    print(f"[TEST] Download attempt result code: {dl_output.returncode}")
                    if os.path.exists(os.path.basename(sample)):
                        print(f"[TEST] Successfully downloaded: {sample}")
                        if os.path.getsize(os.path.basename(sample)) < 1024:
                            with open(os.path.basename(sample), 'r') as f:
                                print(f"[TEST] File content: {f.read()}")
            except subprocess.CalledProcessError as e:
                print(f"[TEST] Failed to access share: {e}")
                print(f"[TEST] Error output: {e.output.decode() if hasattr(e, 'output') else 'No output'}")
    except Exception as e:
        print(f"[TEST] Error: {e}")

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 quickpentest.py <IP>")
        sys.exit(1)
        
    ip = sys.argv[1]
    
    if "--test-smb" in sys.argv:
        test_smb_connection(ip)
        return
        
    run_nmap(ip)
    results = parse_nmap_results()
    generate_report(ip, results)

if __name__ == "__main__":
    main()