#!/usr/bin/env python3
import subprocess
import sys
import re
import shutil
import requests
from datetime import datetime
import os
from alive_progress import alive_bar, config_handler
from colorama import Fore, Style, init as colorama_init

colorama_init()

# Debug mode - set to True to see detailed information
DEBUG = True

# Add your Vulners API key here
VULNERS_API_KEY = "EUOBLZ5P3VY5KZYUBL2EKHZUTI2REOY2CH6YQL90A52D2V0B6DOHX7MFUF17F4SM"  # Replace if needed

SERVICES = {
    21: ("FTP", ["Anonymous access", "Backdoor RCE"], ["nmap", "searchsploit", "metasploit"]),
    22: ("SSH", ["Weak passwords", "Outdated SSHd"], ["nmap", "hydra", "searchsploit"]),
    25: ("SMTP", ["Open relay", "Command injection"], ["nmap", "swaks", "metasploit"]),
    80: ("HTTP", ["XSS, SQLi, RCE", "Outdated Apache/nginx"], ["nmap", "nikto", "burpsuite"]),
    443: ("HTTPS", ["Weak TLS/SSL", "App vulns"], ["sslscan", "owasp zap", "burpsuite"]),
    139: ("NetBIOS", ["Enumerate shares", "SMBv1 enabled"], ["nmap", "smbclient"]),
    445: ("SMB", ["EternalBlue", "Unsecured shares"], ["smbmap", "nmap", "metasploit"]),
    3306: ("MySQL", ["Default creds", "SQLi"], ["sqlmap", "metasploit"]),
    3389: ("RDP", ["BlueKeep", "Weak credentials"], ["nmap", "hydra", "rdesktop"]),
    5432: ("PostgreSQL", ["Default creds", "SQLi"], ["sqlmap", "nmap"]),
    5900: ("VNC", ["No auth", "Weak password"], ["vncviewer", "hydra"]),
    8080: ("HTTP Proxy", ["RCE, SSRF", "Misconfig"], ["nikto", "burpsuite"]),
    10000: ("Webmin", ["RCE", "Default credentials"], ["nmap", "metasploit"])
}

SUSPECT_KEYWORDS = ["share", "myshare", "tmp", "usr", "var", "media", "bin", "secure", "secu", "private", "public"]
SUSPECT_EXTS = [".bak", ".zip", ".rar", ".7z", ".gz", ".secret", ".key", ".pem", ".txt", "password", "passwd", ".conf", ".cnf", ".ini"]

def debug_print(message):
    if DEBUG:
        print(f"[DEBUG] {message}")

def is_tool_installed(tool):
    return shutil.which(tool) is not None

def is_valid_ip(ip):
    return re.match(r"^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$", ip) is not None

def run_nmap(ip, output_file):
    debug_print(f"Scanning {ip} for top 100 ports...")
    cmd = ["nmap", "-sV", "--top-ports", "100", "-Pn", "-oN", output_file, ip]
    subprocess.run(cmd, stderr=subprocess.DEVNULL)

def parse_nmap_results(nmap_file):
    results = []
    try:
        with open(nmap_file, "r") as f:
            for line in f:
                match = re.match(r"^(\d+)/tcp\s+open\s+([\w\-]+)\s+(.*)", line)
                if match:
                    port = int(match.group(1))
                    service = match.group(2)
                    version = match.group(3).strip()
                    results.append((port, service, version))
    except Exception as e:
        print(f"[!] Error parsing nmap results: {e}")
    return results

def search_cves(service, version):
    query = f"{service} {version}"
    url = "https://vulners.com/api/v3/search/lucene/"
    headers = {"User-Agent": "quickpentest"}
    params = {
        "query": query,
        "apiKey": VULNERS_API_KEY,
        "sort": "cvss.score",
        "size": 3
    }
    try:
        r = requests.get(url, headers=headers, params=params, timeout=10)
        if r.status_code == 200:
            data = r.json()
            results = data.get("data", {}).get("search", [])
            if not results:
                return "  ‚û§ No CVEs found for this version. Continuing scan..."
            output = []
            for item in results:
                cve_id = item.get("id")
                score = item.get("cvss", {}).get("score", "N/A")
                title = item.get("title", "")
                output.append(f"    - {cve_id} (CVSS: {score}) ‚Äì {title}")
            return "\n".join(output)
        else:
            return "  ‚û§ Vulners API error. Continuing scan..."
    except Exception as e:
        return f"  ‚û§ CVE search failed: {str(e)}"

def scan_smb_shares(ip, report_file):
    """Simplified SMB share scanner that lists and downloads suspect files."""
    smb_results = []
    smb_results.append(f"\nPHASE: SMB SHARE ANALYSIS\n----------------------------------------\n")

    try:
        debug_print(f"Scanning SMB shares on {ip}")
        cmd = ["smbclient", "-L", f"//{ip}/", "-N"]
        debug_print(f"Running command: {' '.join(cmd)}")
        smb_list = subprocess.check_output(cmd, stderr=subprocess.STDOUT, timeout=30).decode()
        debug_print(f"Raw SMB list output:\n{smb_list[:300]}...")

        shares = re.findall(r"\n\s*(\S+)\s+Disk\s+", smb_list)
        shares = [s for s in shares if s not in ["print$", "IPC$"]]
        shares = list(set(shares))  # Remove duplicates
        debug_print(f"Detected shares: {shares}")

        if not shares:
            smb_results.append("  [!] No SMB shares detected or access denied.\n")
            with open(report_file, "a") as out:
                for line in smb_results:
                    out.write(line)
            return

        smb_results.append(f"  [+] Shares found: {', '.join(shares)}\n")

        for share in shares:
            smb_results.append(f"\n  üìÅ Share: {share}\n")
            debug_print(f"Analyzing share: {share}")
            try:
                # List files recursively
                list_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "prompt OFF; recurse ON; ls"]
                debug_print(f"Running command: {' '.join(list_cmd)}")
                result = subprocess.check_output(list_cmd, stderr=subprocess.DEVNULL, timeout=30).decode()
                debug_print(f"Share listing result preview:\n{result[:300]}...")

                file_count = 0
                suspect_files = []

                for line in result.splitlines():
                    line = line.strip()
                    if not line or 'blocks of size' in line or line.startswith("WARNING"):
                        continue

                    # Skip directory entries
                    if re.search(r"\s+D\s+\d+", line):
                        continue

                    tokens = line.split()
                    if len(tokens) < 2:
                        continue

                    # Extract the full filename with path
                    filename = tokens[0].replace('\\', '/')
                    if filename.startswith('/'):
                        filename = filename[1:]
                    file_count += 1

                    debug_print(f"Processing file: {filename}")

                    # Detect suspect files
                    if any(ext in filename.lower() for ext in SUSPECT_EXTS):
                        suspect_files.append(filename)
                        debug_print(f"Suspect file found: {filename}")

                        # Download file
                        try:
                            get_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", f'get "{filename}"']
                            debug_print(f"Downloading suspect file: {' '.join(get_cmd)}")
                            result = subprocess.run(get_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=30, text=True)
                            if result.returncode == 0:
                                local_filename = os.path.basename(filename)
                                if os.path.exists(local_filename):
                                    debug_print(f"Successfully downloaded {filename} as {local_filename}")
                                    smb_results.append(f"    - Downloaded suspect file: {local_filename}\n")
                                else:
                                    debug_print(f"Download succeeded but file not found locally: {filename}")
                                    smb_results.append(f"    - Downloaded but not found locally: {filename}\n")
                            else:
                                debug_print(f"Failed to download {filename}: {result.stderr}")
                                smb_results.append(f"    - Failed to download suspect file {filename}: {result.stderr}\n")
                        except Exception as e:
                            debug_print(f"Error downloading {filename}: {str(e)}")
                            smb_results.append(f"    - Error downloading suspect file {filename}: {str(e)}\n")

                smb_results.append(f"    - Files found: {file_count}\n")
                if suspect_files:
                    smb_results.append(f"    - üß™ Suspect files:\n")
                    for f in suspect_files:
                        smb_results.append(f"      ‚Ä¢ {f}\n")
                else:
                    smb_results.append("    - No suspect files detected.\n")

            except subprocess.TimeoutExpired:
                smb_results.append(f"    [!] Timeout while listing share {share}\n")
            except subprocess.CalledProcessError as e:
                smb_results.append(f"    [!] Access denied or error listing share {share}: {e.output.decode()}\n")
                debug_print(f"Error accessing share {share}: {e}")

    except subprocess.TimeoutExpired:
        smb_results.append(f"  [!] Timeout during SMB share enumeration\n")
    except subprocess.CalledProcessError as e:
        smb_results.append(f"  [!] SMB enumeration error: {e.output.decode()}\n")
    except Exception as e:
        smb_results.append(f"  [!] Global SMB error: {str(e)}\n")
        debug_print(f"Global SMB scan error: {e}")

    with open(report_file, "a") as out:
        for line in smb_results:
            out.write(line)

def test_smb_connection(ip):
    """Test SMB connection and list shares"""
    print(f"[TEST] Testing SMB connection to {ip}")
    try:
        cmd = ["smbclient", "-L", f"//{ip}/", "-N"]
        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode()
        print(f"[TEST] Output:\n{output}")
        
        shares1 = re.findall(r"\n\s*(\S+)\s+Disk\s+", output)
        shares2 = re.findall(r"(\S+)\s+Disk\s+.*", output)
        
        print(f"[TEST] Detected shares (pattern 1): {shares1}")
        print(f"[TEST] Detected shares (pattern 2): {shares2}")
        
        all_shares = list(set(shares1 + shares2))
        print(f"[TEST] All detected shares: {all_shares}")
        
        for share in all_shares:
            if share in ['print$', 'IPC$'] or share.startswith('-'):
                print(f"[TEST] Skipping standard share: {share}")
                continue
                
            print(f"[TEST] Testing access to share: {share}")
            list_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "ls"]
            try:
                share_output = subprocess.check_output(list_cmd, stderr=subprocess.STDOUT).decode()
                print(f"[TEST] Share content preview:\n{share_output[:200]}...")
                
                recur_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "prompt OFF; recurse ON; ls"]
                recur_output = subprocess.check_output(recur_cmd, stderr=subprocess.STDOUT).decode()
                print(f"[TEST] Recursive listing preview:\n{recur_output[:200]}...")
                
                suspect_files = []
                for line in recur_output.splitlines():
                    if any(ext in line.lower() for ext in [".txt", ".bak", ".conf"]):
                        print(f"[TEST] Suspect file line: {line}")
                        parts = line.split()
                        for part in parts:
                            if "." in part and len(part) > 3:
                                suspect_files.append(part)
                
                print(f"[TEST] Potential suspect files: {suspect_files}")
                
                if suspect_files:
                    sample = suspect_files[0]
                    print(f"[TEST] Attempting to download: {sample}")
                    get_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", f'get "{sample}"']
                    dl_output = subprocess.run(get_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    print(f"[TEST] Download attempt result code: {dl_output.returncode}")
                    if os.path.exists(os.path.basename(sample)):
                        print(f"[TEST] Successfully downloaded: {sample}")
                        if os.path.getsize(os.path.basename(sample)) < 1024:
                            with open(os.path.basename(sample), 'r') as f:
                                print(f"[TEST] File content: {f.read()}")
            except subprocess.CalledProcessError as e:
                print(f"[TEST] Failed to access share: {e}")
                print(f"[TEST] Error output: {e.output.decode() if hasattr(e, 'output') else 'No output'}")
    except Exception as e:
        print(f"[TEST] Error: {e}")

def generate_report(ip, results, report_file):
    """Generate a pentest report with scan results and recommendations."""
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(report_file, "w") as f:
        f.write(f"QuickPentest Report ‚Äì {ip}\n")
        f.write("=" * 50 + "\n")

        f.write(f"Target IP: {ip}\n")
        f.write(f"Date: {now}\n")
        f.write("Method: Black-box\n")
        f.write("Estimated Duration: Automated\n\n")

        f.write("PHASE: SCAN + ENUMERATION\n--------------------------\n")
        for port, service, version in results:
            f.write(f" - Port {port} ({service}) ‚Üí Version: {version}\n")

        f.write("\nPHASE: POSSIBLE VULNERABILITIES\n--------------------------------\n")
        
        # Removed inner alive_bar to avoid nesting
        for port, service, version in results:
            if port in SERVICES:
                name, vulns, tools = SERVICES[port]
                f.write(f"\nPort {port} ({name})\n")
                f.write(f"  ‚û§ Detected Version: {version}\n")
                f.write("  ‚û§ Possible Vulnerabilities:\n")
                for vuln in vulns:
                    f.write(f"    - {vuln}\n")
                f.write("  ‚û§ Recommended Tools:\n")
                for tool in tools:
                    status = "‚úî Installed" if is_tool_installed(tool) else "‚úò Not found"
                    f.write(f"    - {tool} ({status})\n")
                cve_results = search_cves(service, version)
                f.write("  ‚û§ CVE Results:\n")
                f.write(f"{cve_results}\n")
            else:
                f.write(f"\nPort {port} ({service.upper()})\n")
                f.write(f"  ‚û§ Detected Version: {version}\n")
                f.write("  ‚û§ Possible Vulnerabilities: [simulated]...\n")
                f.write("  ‚û§ CVE Results:\n")
                f.write(f"{search_cves(service, version)}\n")

        if any(port in [139, 445] for port, _, _ in results):
            scan_smb_shares(ip, report_file)

        f.write("\nPHASE: POST-SCAN TOOLS\n----------------------------------------\n")
        if is_tool_installed("nikto") and any(port == 80 for port, _, _ in results):
            f.write("[+] Running Nikto on port 80...\n")
            subprocess.run(["nikto", "-host", f"http://{ip}", "-p", "80"], stdout=f, stderr=subprocess.DEVNULL)
        else:
            f.write("‚úò Nikto not installed or port 80 closed. Skipping.\n")

        if is_tool_installed("dirsearch") and any(port == 80 for port, _, _ in results):
            f.write("[+] Running dirsearch...\n")
            subprocess.run(["dirsearch", "-u", f"http://{ip}:80", "-e", "php,txt,html", "--simple-report=dirsearch_report.txt"], stdout=f, stderr=subprocess.DEVNULL)
        else:
            f.write("‚úò dirsearch not installed or port 80 closed. Skipping.\n")

        if is_tool_installed("gobuster") and any(port == 80 for port, _, _ in results):
            f.write("[+] Running Gobuster...\n")
            subprocess.run(["gobuster", "dir", "-u", f"http://{ip}", "-w", "/usr/share/wordlists/dirb/common.txt", "-q", "-o", "gobuster_output.txt"], stdout=f, stderr=subprocess.DEVNULL)
        else:
            f.write("‚úò Gobuster not installed or port 80 closed. Skipping.\n")

        f.write("\nEND OF REPORT ‚Äì Verify results and exploit manually if needed.\n")

    print(f"[+] Report completed in {report_file}")

def main():
    """Main function to orchestrate the pentest scan."""
    if len(sys.argv) < 2:
        print("Usage: python3 quickpentest.py <IP> [--test-smb]")
        sys.exit(1)

    ip = sys.argv[1]
    if not is_valid_ip(ip):
        print("Error: Invalid IP address")
        sys.exit(1)

    if "--test-smb" in sys.argv:
        test_smb_connection(ip)
        return

    now = datetime.now().strftime("%Y%m%d_%H%M%S")
    report_file = f"report_{now}.txt"
    nmap_file = f"nmap_output_{now}.txt"

    # Adjusted steps to account for CVE checks per port
    steps = [" timetamp1 Nmap Scan", "timetamp2 Parse Results"]
    results = []  # Initialize results to avoid undefined variable issues
    with alive_bar(len(steps) + len(results) + 3, title="Pentest Progress", bar='smooth', spinner='dots_waves', length=20) as pbar:
        debug_print("Starting Nmap scan...")
        run_nmap(ip, nmap_file)
        pbar.text = "Running Nmap"
        pbar()

        debug_print("Parsing scan results...")
        results = parse_nmap_results(nmap_file)
        pbar.text = "Parsing Results"
        pbar()

        # Add dynamic steps for CVE checks based on number of open ports
        for i in range(len(results)):
            steps.append(f"Check CVE for Port {results[i][0]}")
            debug_print(f"Checking CVE for port {results[i][0]}...")
            pbar.text = f"Checking CVE for Port {results[i][0]}"
            pbar()

        debug_print("Generating full report...")
        generate_report(ip, results, report_file)
        pbar.text = "Writing Report"
        pbar()

        pbar.text = "SMB Scan (if applicable)"
        pbar()

        pbar.text = "Running Post-Scan Tools"
        pbar()

        pbar.text = "Finalizing"
        pbar()

    print(Fore.GREEN + f"[‚úî] Scan complete. Report saved to {report_file}" + Style.RESET_ALL)

if __name__ == "__main__":
    main()