#!/usr/bin/env python3
import subprocess
import sys
import re
import shutil
import requests
from datetime import datetime
import os

# Debug mode - set to True to see detailed information
DEBUG = True

def debug_print(message):
    if DEBUG:
        print(f"[DEBUG] {message}")

# Add your Vulners API key here
VULNERS_API_KEY = "EUOBLZ5P3VY5KZYUBL2EKHZUTI2REOY2CH6YQL90A52D2V0B6DOHX7MFUF17F4SM"  # <-- insert your actual API key

SERVICES = {
    21:  ("FTP", ["Anonymous access", "Backdoor RCE"], ["nmap", "searchsploit", "metasploit"]),
    22:  ("SSH", ["Weak passwords", "Outdated SSHd"], ["nmap", "hydra", "searchsploit"]),
    25:  ("SMTP", ["Open relay", "Command injection"], ["nmap", "swaks", "metasploit"]),
    80:  ("HTTP", ["XSS, SQLi, RCE", "Outdated Apache/nginx"], ["nmap", "nikto", "burpsuite"]),
    443: ("HTTPS", ["Weak TLS/SSL", "App vulns"], ["sslscan", "owasp zap", "burpsuite"]),
    139: ("NetBIOS", ["Enumerate shares", "SMBv1 enabled"], ["nmap", "smbclient"]),
    445: ("SMB", ["EternalBlue", "Unsecured shares"], ["smbmap", "nmap", "metasploit"]),
    3306: ("MySQL", ["Default creds", "SQLi"], ["sqlmap", "metasploit"]),
    3389: ("RDP", ["BlueKeep", "Weak credentials"], ["nmap", "hydra", "rdesktop"]),
    5432: ("PostgreSQL", ["Default creds", "SQLi"], ["sqlmap", "nmap"]),
    5900: ("VNC", ["No auth", "Weak password"], ["vncviewer", "hydra"]),
    8080: ("HTTP Proxy", ["RCE, SSRF", "Misconfig"], ["nikto", "burpsuite"]),
    10000: ("Webmin", ["RCE", "Default credentials"], ["nmap", "metasploit"])
}

SUSPECT_KEYWORDS = ["share", "myshare", "tmp", "usr", "var", "media", "bin", "secure", "secu", "private", "public"]
SUSPECT_EXTS = [".bak", ".zip", ".rar", ".7z", ".gz", ".secret", ".key", ".pem", ".txt", "password", "passwd", ".conf", ".cnf", ".ini"]

def is_tool_installed(tool):
    return shutil.which(tool) is not None

def run_nmap(ip):
    print(f"[+] Scanning {ip} for top 100 ports...")
    cmd = ["nmap", "-sV", "--top-ports", "100", "-Pn", "-oN", "nmap_output.txt", ip]
    subprocess.run(cmd)

def parse_nmap_results():
    results = []
    try:
        with open("nmap_output.txt", "r") as f:
            for line in f:
                match = re.match(r"^(\d+)/tcp\s+open\s+([\w\-]+)\s+(.*)", line)
                if match:
                    port = int(match.group(1))
                    service = match.group(2)
                    version = match.group(3).strip()
                    results.append((port, service, version))
    except Exception as e:
        print(f"[!] Error parsing nmap results: {e}")
    return results

def search_cves(service, version):
    query = f"{service} {version}"
    url = "https://vulners.com/api/v3/search/lucene/"
    headers = {"User-Agent": "quickpentest"}
    params = {
        "query": query,
        "apiKey": VULNERS_API_KEY,
        "sort": "cvss.score",
        "size": 3
    }
    try:
        r = requests.get(url, headers=headers, params=params, timeout=10)
        if r.status_code == 200:
            data = r.json()
            results = data.get("data", {}).get("search", [])
            if not results:
                return "  ➤ Aucun CVE trouvé pour cette version. Continuation du scan..."
            output = []
            for item in results:
                cve_id = item.get("id")
                score = item.get("cvss", {}).get("score", "N/A")
                title = item.get("title", "")
                output.append(f"    - {cve_id} (CVSS: {score}) – {title}")
            return "\n".join(output)
        else:
            return "  ➤ Erreur API Vulners. Scan continue..."
    except Exception as e:
        return f"  ➤ Recherche CVE échouée: {str(e)}"

def scan_smb_shares(ip, report_file):
    """Enhanced SMB share scanner with better error handling and file detection"""
    smb_results = []
    smb_results.append(f"PHASE: ANALYSE DES PARTAGES SMB\n----------------------------------------\n")
    
    try:
        debug_print(f"Scanning SMB shares on {ip}")
        # List all shares - try different methods
        try:
            cmd = ["smbclient", "-L", f"//{ip}/", "-N"]
            debug_print(f"Running command: {' '.join(cmd)}")
            smb_list = subprocess.check_output(cmd, stderr=subprocess.STDOUT, timeout=30).decode()
            debug_print(f"Raw SMB list output: {smb_list[:200]}...")
            
            # Try different regex patterns
            shares = []
            # Pattern 1: Common format
            shares_match = re.findall(r"\n\s*(\S+)\s+Disk\s+", smb_list)
            if shares_match:
                shares.extend(shares_match)
            
            # Pattern 2: Alternative format (Sharename Type Comment)
            alt_shares = re.findall(r"(\S+)\s+Disk\s+.*", smb_list)
            if alt_shares:
                shares.extend([s for s in alt_shares if s not in shares])
                
            # Remove common irrelevant shares
            shares = [s for s in shares if s not in ["print$", "IPC$"] and not s.startswith("-")]
            
            # Deduplicate
            shares = list(set(shares))
            
            debug_print(f"Detected shares: {shares}")
            
            if not shares:
                smb_results.append("  [!] Aucun partage SMB trouvé ou accès refusé\n")
                debug_print("No shares detected!")
            else:
                smb_results.append(f"  [+] Partages SMB trouvés: {', '.join(shares)}\n")
                
                for share in shares:
                    smb_results.append(f"\n  📁 Analyse du partage: {share}\n")
                    debug_print(f"Analyzing share: {share}")
                    
                    try:
                        # First, test if we can access the share
                        test_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "ls"]
                        subprocess.check_output(test_cmd, stderr=subprocess.STDOUT, timeout=10)
                        
                        # Now list files recursively
                        list_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "prompt OFF; recurse ON; ls"]
                        debug_print(f"Running command: {' '.join(list_cmd)}")
                        result = subprocess.check_output(list_cmd, stderr=subprocess.STDOUT, timeout=30).decode()
                        debug_print(f"Share listing result preview: {result[:200]}...")
                        
                        # Count files and look for suspect files
                        file_count = 0
                        suspect_files = []
                        
                        # Process each line
                        for line in result.splitlines():
                            line = line.strip()
                            if not line:
                                continue
                                
                            # Skip lines that clearly indicate directories
                            if line.endswith("/") or "D " in line or "<DIR>" in line:
                                continue
                                
                            file_count += 1
                            debug_print(f"Found file: {line}")
                            
                            # Check if this line contains a suspect file
                            if any(ext in line.lower() for ext in SUSPECT_EXTS):
                                debug_print(f"Suspect file found in line: {line}")
                                
                                # Try several methods to extract the filename
                                filename = None
                                
                                # Method 1: Look for the last word that has an extension
                                parts = line.split()
                                for part in reversed(parts):
                                    if "." in part and any(ext in part.lower() for ext in SUSPECT_EXTS):
                                        filename = part
                                        break
                                
                                # Method 2: If the line has few parts, it might be just the filename
                                if not filename and len(parts) <= 3 and "." in line:
                                    filename = line.strip()
                                
                                # Method 3: Look for the last word if it contains suspicious keywords
                                if not filename and parts:
                                    last_word = parts[-1]
                                    if any(keyword in last_word.lower() for keyword in ["password", "secret", "passwd"]):
                                        filename = last_word
                                
                                if filename:
                                    suspect_files.append(filename)
                                    debug_print(f"Extracted suspect filename: {filename}")
                        
                        smb_results.append(f"    - {file_count} fichier(s) trouvé(s)\n")
                        
                        # Download suspect files
                        for filename in suspect_files:
                            smb_results.append(f"    🧪 Fichier suspect trouvé: {filename}\n")
                            debug_print(f"Attempting to download: {filename}")
                            
                            try:
                                # Sanitize filename
                                safe_filename = filename.replace('"', '\\"')
                                # Try different methods to download
                                
                                # Method 1: Direct smbclient get
                                read_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", f'more "{safe_filename}"']
                                debug_print(f"Running command to read content: {' '.join(read_cmd)}")

                                try:
                                    output = subprocess.check_output(read_cmd, stderr=subprocess.STDOUT, timeout=10).decode()
                                    content_lines = output.strip().splitlines()
                                    if content_lines:
                                        smb_results.append(f"      [+] Contenu extrait de {filename} :\n")
                                        for line in content_lines:
                                            if line.strip():
                                                smb_results.append(f"        {line.strip()}\n")
                                    else:
                                        smb_results.append(f"      [!] Aucun contenu lu dans {filename}.\n")
                                except subprocess.CalledProcessError as e:
                                    debug_print(f"[!] Erreur de lecture avec 'more': {e}")
                                    smb_results.append(f"      [!] Impossible de lire {filename} (via more)\n")
                                debug_print(f"Running command: {' '.join(get_cmd)}")
                                ret = subprocess.run(get_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=20)
                                
                                # Check if file was successfully downloaded
                                if os.path.exists(os.path.basename(safe_filename)):
                                    smb_results.append(f"      [+] Téléchargé avec succès: {filename}\n")
                                    debug_print(f"Successfully downloaded: {filename}")
                                    
                                    # Try to display file content if it's small enough
                                    file_path = os.path.basename(safe_filename)
                                    if os.path.getsize(file_path) < 1024:  # Less than 1KB
                                        try:
                                            with open(file_path, 'r') as f:
                                                content = f.read().strip()
                                                smb_results.append(f"      [+] Contenu du fichier:\n      -------------------\n      {content}\n      -------------------\n")
                                        except Exception as e:
                                            debug_print(f"Failed to read file content: {e}")
                                else:
                                    # Method 2: Try with simplified path
                                    base_filename = os.path.basename(safe_filename)
                                    get_cmd2 = ["smbclient", f"//{ip}/{share}", "-N", "-c", f'get "{base_filename}"']
                                    debug_print(f"Trying simplified command: {' '.join(get_cmd2)}")
                                    subprocess.run(get_cmd2, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=20)
                                    
                                    if os.path.exists(base_filename):
                                        smb_results.append(f"      [+] Téléchargé avec succès (méthode alternative): {base_filename}\n")
                                        debug_print(f"Successfully downloaded (alternative method): {base_filename}")
                                        
                                        # Try to display file content
                                        if os.path.getsize(base_filename) < 1024:  # Less than 1KB
                                            try:
                                                with open(base_filename, 'r') as f:
                                                    content = f.read().strip()
                                                    smb_results.append(f"      [+] Contenu du fichier:\n      -------------------\n      {content}\n      -------------------\n")
                                            except Exception as e:
                                                debug_print(f"Failed to read file content: {e}")
                                    else:
                                        debug_print("Both download methods failed")
                                        smb_results.append(f"      [!] Échec téléchargement: {filename}\n")
                            except subprocess.CalledProcessError as e:
                                err_output = e.stderr.decode() if e.stderr else "Unknown error"
                                debug_print(f"Download error: {err_output}")
                                smb_results.append(f"      [!] Échec téléchargement: {filename} - {err_output}\n")
                            except Exception as e:
                                debug_print(f"Download exception: {str(e)}")
                                smb_results.append(f"      [!] Erreur lors du téléchargement: {str(e)}\n")
                    
                    except subprocess.CalledProcessError as e:
                        error_msg = e.stderr.decode() if hasattr(e, 'stderr') and e.stderr else "Unknown error"
                        debug_print(f"Share access error: {error_msg}")
                        smb_results.append(f"    [!] Échec de l'analyse du partage {share}: {error_msg}\n")
                    except Exception as e:
                        debug_print(f"Share analysis exception: {str(e)}")
                        smb_results.append(f"    [!] Erreur lors de l'analyse du partage {share}: {str(e)}\n")
        
        except subprocess.CalledProcessError as e:
            error_msg = e.stderr.decode() if hasattr(e, 'stderr') and e.stderr else "Unknown error"
            debug_print(f"SMB list error: {error_msg}")
            smb_results.append(f"  [!] Échec de la connexion SMB: {error_msg}\n")
        except Exception as e:
            debug_print(f"SMB list exception: {str(e)}")
            smb_results.append(f"  [!] Erreur lors de la connexion SMB: {str(e)}\n")
    
    except Exception as e:
        debug_print(f"Global SMB error: {str(e)}")
        smb_results.append(f"  [!] Erreur globale analyse SMB: {str(e)}\n")
    
    # Write all results at once
    with open(report_file, "a") as out:
        for line in smb_results:
            out.write(line)

def generate_report(ip, results):
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open("report.txt", "w") as f:
        f.write(f"Rapport de Pentest – Généré automatiquement\n")
        f.write(f"IP Cible: {ip}\nDate: {now}\nDurée estimée: Automatisée\nMéthode: Boîte noire\n\n")
        f.write("PHASE: SCAN + ENUMÉRATION\n--------------------------\n\n")
        for port, service, version in results:
            f.write(f" - Port {port} ({service}) → Version: {version}\n")

        f.write("\nPHASE: VULNÉRABILITÉS POSSIBLES\n--------------------------------\n")
        for port, service, version in results:
            if port in SERVICES:
                name, vulns, tools = SERVICES[port]
                f.write(f"Port {port} ({name})\n")
                f.write(f"  ➤ Version détectée: {version}\n")
                f.write("  ➤ Vulnérabilités possibles:\n")
                for vuln in vulns:
                    f.write(f"    - {vuln}\n")
                f.write("  ➤ Outils recommandés:\n")
                for tool in tools:
                    status = "✔ installé" if is_tool_installed(tool) else "✘ non trouvé"
                    f.write(f"    - {tool} ({status})\n")
                cve_results = search_cves(service, version)
                f.write("  ➤ Résultats CVE :\n")
                f.write(f"{cve_results}\n\n")
        
        # Now scan SMB shares if ports 139 or 445 are open
        # IMPORTANT: Notice we're calling scan_smb_shares directly and not writing an additional header
        if any(port in [139, 445] for port, _, _ in results):
            scan_smb_shares(ip, "report.txt")
        
        # Continue with POST-SCAN TOOLS
        f.write("\nPHASE: POST-SCAN (si outils disponibles)\n----------------------------------------\n")
        if is_tool_installed("nikto") and any(port == 80 for port, _, _ in results):
            f.write("[+] Lancement rapide de Nikto sur port 80...\n")
            subprocess.run(["nikto", "-host", f"http://{ip}", "-p", "80"])
        else:
            f.write("✘ nikto non installé ou port 80 fermé. Étape ignorée.\n")

        if is_tool_installed("dirsearch") and any(port == 80 for port, _, _ in results):
            f.write("[+] Exécution rapide de dirsearch...\n")
            subprocess.run(["dirsearch", "-u", f"http://{ip}:80", "-e", "php,txt,html", "--simple-report=dirsearch_report.txt"])
        else:
            f.write("✘ dirsearch non installé ou port 80 fermé. Étape ignorée.\n")

        if is_tool_installed("gobuster") and any(port == 80 for port, _, _ in results):
            f.write("[+] Gobuster dir...\n")
            subprocess.run(["gobuster", "dir", "-u", f"http://{ip}", "-w", "/usr/share/wordlists/dirb/common.txt", "-q", "-o", "gobuster_output.txt"])
        else:
            f.write("✘ gobuster non installé ou port 80 fermé. Étape ignorée.\n")

        f.write("\nFIN DU RAPPORT – Vérifiez les téléchargements et exploitez manuellement si nécessaire.\n")

    print("[+] Rapport terminé dans report.txt")

def test_smb_connection(ip):
    """Test SMB connection and list shares"""
    print(f"[TEST] Testing SMB connection to {ip}")
    try:
        cmd = ["smbclient", "-L", f"//{ip}/", "-N"]
        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode()
        print(f"[TEST] Output:\n{output}")
        
        # Try different regex patterns for shares
        shares1 = re.findall(r"\n\s*(\S+)\s+Disk\s+", output)
        shares2 = re.findall(r"(\S+)\s+Disk\s+.*", output)
        
        print(f"[TEST] Detected shares (pattern 1): {shares1}")
        print(f"[TEST] Detected shares (pattern 2): {shares2}")
        
        # Combine and deduplicate
        all_shares = list(set(shares1 + shares2))
        print(f"[TEST] All detected shares: {all_shares}")
        
        # Test accessing each share
        for share in all_shares:
            if share in ['print$', 'IPC$'] or share.startswith('-'):
                print(f"[TEST] Skipping standard share: {share}")
                continue
                
            print(f"[TEST] Testing access to share: {share}")
            list_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "ls"]
            try:
                share_output = subprocess.check_output(list_cmd, stderr=subprocess.STDOUT).decode()
                print(f"[TEST] Share content preview:\n{share_output[:200]}...")
                
                # Try recursive listing
                recur_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", "prompt OFF; recurse ON; ls"]
                recur_output = subprocess.check_output(recur_cmd, stderr=subprocess.STDOUT).decode()
                print(f"[TEST] Recursive listing preview:\n{recur_output[:200]}...")
                
                # Try to find suspect files
                suspect_files = []
                for line in recur_output.splitlines():
                    if any(ext in line.lower() for ext in [".txt", ".bak", ".conf"]):
                        print(f"[TEST] Suspect file line: {line}")
                        parts = line.split()
                        for part in parts:
                            if "." in part and len(part) > 3:  # Simple heuristic for filenames
                                suspect_files.append(part)
                
                print(f"[TEST] Potential suspect files: {suspect_files}")
                
                # Try downloading a sample file if any found
                if suspect_files:
                    sample = suspect_files[0]
                    print(f"[TEST] Attempting to download: {sample}")
                    get_cmd = ["smbclient", f"//{ip}/{share}", "-N", "-c", f'get "{sample}"']
                    dl_output = subprocess.run(get_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    print(f"[TEST] Download attempt result code: {dl_output.returncode}")
                    if os.path.exists(os.path.basename(sample)):
                        print(f"[TEST] Successfully downloaded: {sample}")
                        # Try to read it if small
                        if os.path.getsize(os.path.basename(sample)) < 1024:
                            with open(os.path.basename(sample), 'r') as f:
                                print(f"[TEST] File content: {f.read()}")
            except subprocess.CalledProcessError as e:
                print(f"[TEST] Failed to access share: {e}")
                print(f"[TEST] Error output: {e.output.decode() if hasattr(e, 'output') else 'No output'}")
    except Exception as e:
        print(f"[TEST] Error: {e}")

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 quickpentest.py <IP>")
        sys.exit(1)
        
    ip = sys.argv[1]
    
    # Test SMB functionality if requested
    if "--test-smb" in sys.argv:
        test_smb_connection(ip)
        return
        
    # Normal execution
    run_nmap(ip)
    results = parse_nmap_results()
    generate_report(ip, results)

if __name__ == "__main__":
    main()